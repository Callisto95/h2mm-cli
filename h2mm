#!/bin/bash

VERSION="0.2.4"

# --- Globals ---

RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'
NC='\033[0m'

H2PATH="${HOME}/.config/h2mm/h2path"
MODS_DIR=""
DB_FILE=""

LAST_CHECKED_UPDATE_FILE="${HOME}/.config/h2mm/last_update"
VERSION_URL="https://raw.githubusercontent.com/v4n00/h2mm-cli/refs/heads/master/version"
REPO_URL="https://github.com/v4n00/h2mm-cli"

# --- Utility Functions ---

function get_filename_without_path() {
	echo "$1" | awk -F/ '{print $NF}'
}

function get_basename() {
	get_filename_without_path "$1" | sed -E 's/\.+.*//'
}

function get_basename_with_patch_without_extension() {
	echo "$1" | sed -E "s/(.*[0-9]+).*/\1/"
}

function get_extension() {
	get_filename_without_path "$1" | sed -E 's/.*patch_[0-9]+//'
}

function get_files_by_entry_from_db() {
	echo "$1" | cut -d',' -f4- | tr ',' ' ' | head -1
}

function get_mod_name_and_index() {
	if [[ -n "$mod_index" ]]; then # if mod index exists
		entry=$(grep "^${mod_index}," "$DB_FILE")
		mod_name=$(echo "$entry" | awk -F, '{print $3}')
	elif [[ -n "$mod_name" ]]; then # if mod name exists
		entry=$(grep -i ",$mod_name," "$DB_FILE")
		mod_index=$(echo "$entry" | awk -F, '{print $1}' | head -1)
	fi

	if [[ -z "$entry" || -z "$mod_index" || -z "$mod_name" ]]; then
		echo -e "${RED}Error${NC}: Mod not found." >&2
		exit 1
	fi

	status=$(echo "$entry" | awk -F, '{print $2}')
}

function find_game_directory() {
	local search_dir="${HOME}"
	local target_dir="Steam/steamapps/common/Helldivers\ 2/data"

	# check if path is saved
	if [[ -f "$H2PATH" ]]; then
		saved_dir=$(cat "$H2PATH")
		if [[ -d "$saved_dir" ]]; then
			echo "$saved_dir"
			return
		else
			echo "Saved game directory is invalid."
		fi
	fi

	# first time setup, or directory is not valid anymore
	echo "Searching for the Helldivers 2 data directory..." >&2
	game_dir=$(find "$search_dir" -type d -path "*/$target_dir" 2>/dev/null | head -n 1)

	if [[ -z "$game_dir" ]]; then
		echo "Could not find the Helldivers 2 data directory automatically." >&2
		IFS= read -ep "Please enter the path to the Helldivers 2 data directory: " game_dir
		if [[ ! -d "$game_dir" ]]; then
			echo -e "${RED}Error${NC}: Provided path is not a valid directory." >&2
			exit 1
		fi
	fi

	mkdir -p "$(dirname "$H2PATH")"
	echo "$game_dir" > "$H2PATH"

	if [[ $? -eq 0 ]]; then
		echo -e "Game directory ${GREEN}saved${NC}: $game_dir" >&2
	else
		echo -e "${RED}Error${NC}: Could not save game directory." >&2
		exit 1
	fi
	
	echo "$game_dir"
}

function initialize_directories() {
	MODS_DIR=$(find_game_directory)
	DB_FILE="$MODS_DIR/mods.csv"

	if [[ ! -f "$DB_FILE" ]]; then
		touch "$DB_FILE"
		if [[ $? -eq 0 ]]; then
			echo -e "Database file ${GREEN}created${NC}: $DB_FILE"
		else
			echo -e "${RED}Error${NC}: Could not create database file." >&2
			exit 1
		fi
	fi
}

# --- Help Functions ---

function display_help() {
	echo "Helldivers 2 Mod Manager v${VERSION}"
	echo "Usage: h2mm [command] [options]"
	echo "Commands:"
	echo "	install					Install a mod with files."
	echo "	uninstall				Uninstall a mod by name."
	echo "	list					List all installed mods."
	echo "	enable					Enable a mod by name."
	echo "	disable					Disable a mod by name."
	echo "	export <zip_name>			Export installed mods to a zip file."
	echo "	import <zip_name>			Import mods from a zip file."
	echo "	reset					Reset all installed mods."
	echo "	help					Display this help message."
	echo "For more information on usage, use h2mm [command] --help, available for install and uninstall."
	echo "Basic Usage:"
	echo "	h2mm install /path/to/mod.zip"
	echo "	h2mm install /path/to/mod/files"
	echo "	h2mm uninstall \"Example mod\""
}

function display_install_help() {
	echo "Usage: h2mm install [options] <mod_files|mod_dir|mod_zip>"
	echo "Short form: h2mm i"
	echo "Options:"
	echo "	-n \"<mod_name>\"		Name the mod yourself, inside double quotes."
	echo "	<mod_files>		Multiple mod files, accepts wildcards."
	echo "	<mod_dirs>		Directory/directories containing mod files."
	echo "	<mod_zips>		Zip file(s) containing mod files."
	echo "Usage:"
	echo "	h2mm install /path/to/mod.zip"
	echo "	h2mm install /path/to/mod/files"
	echo "	h2mm install /path/to/mod.zip /path/to/mod2.zip /path/to/mod/files"
	echo "	h2mm install -n \"Example mod\" mod.patch_0 mod.patch_0.stream # -n is mandatory when using files"
	echo "	h2mm install -n \"Example mod\" mod* # using a wildcard to include all files"
	echo "If the mod has more than 1 variant, you need to install the one you want by unarchiving it separately."
}

function display_uninstall_help() {
	echo "Usage: h2mm uninstall [options] \"<mod_name>\""
	echo "Short form: h2mm u"
	echo "Options:"
	echo "	-i <index>		Index of the mod to uninstall."
	echo "Usage:"
	echo "	h2mm uninstall \"Example mod\""
	echo "	h2mm uninstall -i 1 # uninstall mod with index 1"
}

function display_enable_help() {
	echo "Usage: h2mm enable [options] \"<mod_name>\""
	echo "Short form: h2mm e"
	echo "Options:"
	echo "	-i <index>		Index of the mod to enable."
	echo "Usage:"
	echo "	h2mm enable \"Example mod\""
	echo "	h2mm enable -i 1 # enable mod with index 1"
}

function display_disable_help() {
	echo "Usage: h2mm disable [options] \"<mod_name>\""
	echo "Short form: h2mm d"
	echo "Options:"
	echo "	-i <index>		Index of the mod to disable."
	echo "Usage:"
	echo "	h2mm disable \"Example mod\""
	echo "	h2mm disable -i 1 # disable mod with index 1"
}

function display_list_help() {
	echo "Usage: h2mm list"
	echo "Short form: h2mm l"
	echo "List all installed mods."
	echo "Database of mods is stored in Steam/steamapps/common/Helldivers\ 2/data/mods.csv"
	echo "You can rename, delete, or edit this file to manage mods manually."
}

function display_reset_help() {
	echo "Usage: h2mm reset"
	echo "Short form: h2mm r"
	echo "Reset all installed mods."
	echo "Deletes all installed mods and the database file."
	echo "Database of mods is stored in Steam/steamapps/common/Helldivers\ 2/data/mods.csv, along with the mods."
}

function display_export_help() {
	echo "Usage: h2mm export"
	echo "Short form: h2mm ex"
	echo "Export installed mods and database to a zip file."
}

function display_import_help() {
	echo "Usage: h2mm import"
	echo "Short form: h2mm im"
	echo "Import mods and database from a zip file (coming from h2mm)."
}

# --- Main Functions ---

# Check for updates

function check_for_updates() {
	if [[ -f "$LAST_CHECKED_UPDATE_FILE" ]]; then
		last_update=$(cat "$LAST_CHECKED_UPDATE_FILE")
		if [[ $(date +%Y-%m-%d) -gt $(date +%Y-%m-%d -d "$last_update + 3 days") ]]; then
			return
		fi
	else
		echo $(date +%Y-%m-%d) > "$LAST_CHECKED_UPDATE_FILE"
		exit 0
	fi

	latest_version=$(curl -sS "$VERSION_URL")
	if [[ $? -ne 0 ]]; then
		echo "${RED}Error:${NC} Could not check for updates." >&2
		return
	fi

	if [[ "$latest_version" != "$VERSION" ]]; then
		echo -e "${RED}!${NC} A new version of h2mm is available: ${ORANGE}$VERSION${NC} -> ${GREEN}$latest_version${NC}" >&2
		echo -e "${RED}!${NC} You can download it from: $REPO_URL" >&2
	fi

	echo $(date +%Y-%m-%d) > "$LAST_CHECKED_UPDATE_FILE"
}

# Mod management

function mod_disable() {
	local mod_name=""
	local mod_index=""

	[[ $# -eq 0 ]] && { display_disable_help; exit 0; }

	# parse arguments
	while [[ $# -gt 0 ]]; do
		case "$1" in
			-i)
				mod_index="$2"; shift 2
				;;
			--help|-h)
				display_disable_help; exit 0
				;;
			*)
				mod_name="$1"; shift 1
				;;
		esac
	done

	if [[ -z "$mod_name" && -z "$mod_index" ]]; then
		echo -e "${RED}Error${NC}: Mod name or index is required to disable." >&2
		exit 1
	fi

	# find mod files
	get_mod_name_and_index "$mod_name" "$mod_index"
	
	if [[ "$status" == "DISABLED" ]]; then
		echo -e "${RED}Error${NC}: Mod $mod_name is already disabled." >&2
		exit 1
	fi

	# disable each mod file by adding disabled_ to the start of the filename
	files=$(get_files_by_entry_from_db "$entry")
	for file in $files; do
		if [[ ! -f "$MODS_DIR/$file" ]]; then
			echo -e "${RED}Error${NC}: Mod file $file does not exist." >&2
			exit 1
		else
			disabled_file="disabled_$file"
			mv "$MODS_DIR/$file" "$MODS_DIR/$disabled_file"
			echo -e "Disabled ${ORANGE}$file${NC} (changed to ${GREEN}\$MODS_DIR/$disabled_file${NC})." >&2
		fi
	done

	# update the database
	sed -i "/^$mod_index,/s/ENABLED/DISABLED/" "$DB_FILE"

	if [[ $? -eq 0 ]]; then
		echo -e "Mod $mod_name ${ORANGE}disabled${NC} successfully." >&2
	else
		echo -e "${RED}Error${NC}: Failed to disable mod." >&2
		exit 1
	fi
}

function mod_enable() {
	local mod_name=""
	local mod_index=""

	[[ $# -eq 0 ]] && { display_enable_help; exit 0; }

	# parse arguments
	while [[ $# -gt 0 ]]; do
		case "$1" in
			-i)
				mod_index="$2"; shift 2
				;;
			--help|-h)
				display_enable_help; exit 0
				;;
			*)
				mod_name="$1"; shift 1
				;;
		esac
	done

	[[ -z "$mod_name" && -z "$mod_index" ]] && { echo -e "${RED}Error${NC}: Mod name or index is required to enable." >&2; exit 1; }

	# find mod files
	get_mod_name_and_index "$mod_name" "$mod_index"

	[[ "$status" == "ENABLED" ]] && { echo -e "${RED}Error${NC}: Mod $mod_name is already enabled." >&2; exit 1; }

	files=$(get_files_by_entry_from_db "$entry")

	# enable each mod file by removing disabled_ from the start of the filename
	for file in $files; do
		disabled_file="disabled_$file"

		# check if the files exists
		[[ -f "$MODS_DIR/$disabled_file" ]] || { echo -e "${RED}Error${NC}: Mod file $file does not exist." >&2; exit 1; }

		mv "$MODS_DIR/$disabled_file" "$MODS_DIR/$file"

		# check if the file was moved successfully
		[[ $? -ne 0 ]] && { echo -e "${RED}Error${NC}: Could not enable mod file $disabled_file." >&2; exit 1; }
		echo -e "Enabled ${ORANGE}$disabled_file${NC} (changed to ${GREEN}\$MODS_DIR/$file${NC})." >&2
	done

	# update the database
	sed -i "/^$mod_index,/s/DISABLED/ENABLED/" "$DB_FILE"

	if [[ $? -eq 0 ]]; then
		echo -e "Mod $mod_name ${GREEN}enabled${NC} successfully." >&2
	else
		echo -e "${RED}Error${NC}: Failed to enable mod." >&2
		exit 1
	fi
}

function mod_reset() {
	if [[ "$1" == "--help" || "$1" == "-h" ]]; then
		display_reset_help
		exit 0
	fi

	read -p "Are you sure you want to reset all installed mods? (Y/n): " confirm
	if [[ "$confirm" == "y" || "$confirm" == "Y" || "$confirm" = "" ]]; then
		rm -f "$MODS_DIR"/*.patch_*
		rm -f "$DB_FILE"
		rm -f "$H2PATH"
		echo "Mods and database file deleted."
	else
		echo "Reset cancelled." >&2
		exit 1
	fi
}

function mod_install() {
	local mod_name=""
	local mod_dir=()
	local mod_files=()
	local mod_zip=()

	[[ $# -eq 0 ]] && { display_install_help; exit 0; }

	# parse arguments
	while [[ $# -gt 0 ]]; do
		case "$1" in
		-n)
			mod_name="$2"; shift 2
			;;
		--help|-h)
			display_install_help; exit 0
			;;
		*)
			if [[ -f "$1" && "$1" == *.zip ]]; then
				mod_zip+=("$1")
			elif [[ -d "$1" ]]; then
				mod_dir+=("$1")
			else
				mod_files+=("$1")
			fi
			shift
			;;
		esac
	done

	# edge case when there is a combination of mod zips and directories, call function for all zips and dirs
	if [[ ${mod_zip} && ${mod_dir} ]]; then
		mod_install "${mod_zip[@]}"
		mod_install "${mod_dir[@]}"

		# reset arrays
		mod_zip=()
		mod_dir=()

		# if there are no more arguments, exit
		[[ ${#mod_files[@]} -eq 0 ]] && exit 0
	fi

	# if there's more than 1 zip, call recursively
	while [[ ${#mod_zip[@]} -gt 1 ]]; do
		mod_install "${mod_zip[0]}"
		mod_zip=("${mod_zip[@]:1}")
	done
	
	# extract the zip file and pass it to mod dirs
	if [[ -n "$mod_zip" ]]; then
		command -v unzip &> /dev/null || { echo -e "${RED}Error${NC}: unzip package is not installed." >&2; exit 1; }

		[[ ! -f "$mod_zip" ]] && { echo -e "${RED}Error${NC}: Zip file $mod_zip does not exist." >&2; exit 1; }

		# if the name is not specified, use the name of the directory, last sed for making nexusmods names not have numbers
		if [[ -z "$mod_name" ]]; then
			mod_name=$(basename "$mod_zip" | sed -E 's/\.zip//' | awk -F/ '{print $NF}' | sed -E 's/-[0-9]+-.*//')
		fi

		# mod_dir as a temporary directory
		mod_dir+=$(mktemp -d)
		unzip -qq "$mod_zip" -d "$mod_dir"
	fi

	# if there's more than 1 directory, call recursively
	while [[ ${#mod_dir[@]} -gt 1 ]]; do
		mod_install "${mod_dir[0]}"
		mod_dir=("${mod_dir[@]:1}")
	done

	# directory containing mod files
	if [[ -n "$mod_dir" ]]; then
		# verify directory exists
		[[ ! -d "$mod_dir" ]] && { echo -e "${RED}Error${NC}: Directory $mod_dir does not exist." >&2; exit 1; }

		# read every file from the directory
		readarray -d '' mod_files < <(find "$mod_dir" -type f -name "*.patch_*" -print0)
		# if the name is not specified, use the name of the directory, last sed for making nexusmods names not have numbers
		if [[ -z "$mod_name" ]]; then
			mod_name=$(echo "$mod_dir" | sed 's:/*$::' | awk -F/ '{print $NF}' | sed -E 's/-[0-9]+-.*//')
		fi
	fi
	
	# verify minimum information required
	[[ -z "$mod_name" || ${#mod_files[@]} -eq 0 ]] && { echo -e "${RED}Error${NC}: Mod name and files are required." >&2; exit 1; }

	# verify mod files exist
	for file in "${mod_files[@]}"; do
		[[ ! -f "$file" ]] && { echo -e "${RED}Error${NC}: Mod file $file does not exist." >&2; exit 1; }
	done

	# hash table - in case multiple named files are needed for 1 mod install, store the patch count
	declare -A patch_count
	# store the target files so we can put them in the database later
	target_files=()
	# sort the mod files because with the below logic, the .stream and .gpu_resources files need to come after their respective patch files
	IFS=$'\n' mod_files=($(printf "%s\n" "${mod_files[@]}" | sort -t. -k1,1 -k2,2n)); unset IFS

	for file in "${mod_files[@]}"; do
		base_name=$(get_basename "$file")
		patch_prefix="$MODS_DIR/${base_name}.patch_"
		# count already installed patches
		count=$(ls "${patch_prefix}"* 2>/dev/null | grep -E '([0-9]+$)' 2>/dev/null | wc -l)

		# set patch count for file name if it doesn't exist yet
		if [[ -z "${patch_count[$file]+unset}" ]]; then
			patch_count["$file"]=$count 
		fi
		# if the file has an extension (e.g. .stream, .gpu_resources), set the last patch number for the next step
		patch_count["$base_name"]=$count

		# if the file has an extension, look for the last patch number and use that, otherwise, the count will be wrong
		extension=$(get_extension "$file")
		if [[ -n "$extension" ]]; then
			target_file="${base_name}.patch_$((patch_count[$base_name] - 1))${extension}"
		else
			target_file="${base_name}.patch_${patch_count[$file]}"
		fi
		
		target_files+=($target_file)
		cp "$file" "$MODS_DIR/$target_file"

		# verify installation worked
		[[ $? -ne 0 ]] && { echo -e "${RED}Error${NC}: Could not install mod file $file." >&2; exit 1; }
		echo -e "Mod file ${ORANGE}$file${NC} installed at ${GREEN}\$MODS_DIR/$target_file${NC}." >&2
	done

	# add entry to database
	next_id=$(awk -F, 'END {print $1 + 1}' "$DB_FILE")
	echo "$next_id,ENABLED,$mod_name,${target_files[*]}" >> "$DB_FILE"
	echo -e "Mod $mod_name ($base_name) ${GREEN}installed${NC} successfully." >&2
}

function mod_uninstall() {
	local mod_name=""
	local mod_index=""

	[[ $# -eq 0 ]] && { display_uninstall_help; exit 0; }

	# parse arguments
	while [[ $# -gt 0 ]]; do
		case "$1" in
			-i)
				mod_index="$2"; shift 2
				;;
			--help|-h)
				display_uninstall_help; exit 0
				;;
			*)
				mod_name="$1"; shift 1
				;;
		esac
	done

	[[ -z "$mod_name" && -z "$mod_index" ]] && { echo -e "${RED}Error${NC}: Mod name or index is required to uninstall." >&2; exit 1; }

	# find mod files
	get_mod_name_and_index "$mod_name" "$mod_index"

	# delete mod files
	files=$(get_files_by_entry_from_db "$entry")
	declare -A downgrades_versions
	declare -A downgrades_to_remove
	for file in $files; do
		[[ ! -f "$MODS_DIR/$file" ]] && { echo -e "${RED}Error${NC}: Mod file $file does not exist." >&2; exit 1; }

		echo -e "Removing ${ORANGE}\$MODS_DIR/$file${NC}." >&2
		rm "$MODS_DIR/$file"

		[[ $? -ne 0 ]] && { echo -e "${RED}Error${NC}: Could not remove mod file $file." >&2; exit 1; }

		# save the basename for the files that were deleted into a hash table, so we can downgrade mods with greater version number
		# also depending on how many patches the mod has, we need to downgrade with more versions
		current_version=$(echo $file | grep -oP '(?<=patch_)\d+')
		base_name_with_patch=$(get_basename_with_patch_without_extension "$file")
		base_name=$(get_basename "$file")
		downgrades_versions["$base_name_with_patch"]=$current_version
		[[ -z "${downgrades_to_remove["$base_name"]+unset}" ]] && downgrades_to_remove["$base_name"]=$(echo $files | sed -E "s/(.*[0-9]+).*/\1/" | wc -l)
	done

	# downgrade any necessary mods - it takes ~20 minutes to re-understand this code so I'm writing a comment here
	# for each base name, find all files that have the same base name, and are greater than the current version, and downgrade them
	# the downgrades_versions hash table stores the current version, so we can compare it with the version of the files
	# the downgrades_to_remove hash table stores the number of patches the mod has, so we can downgrade with more versions
	# for example, if we have:
	# mod 1: AAA.patch_0 AAA.patch_0.stream AAA.patch_1 AAA.patch_1.stream
	# mod 2: AAA.patch_2 AAA.patch_2.stream AAA.patch_3 AAA.patch_3.stream
	# mod 3: AAA.patch_4 AAA.patch_4.stream AAA.patch_5 AAA.patch_5.stream
	# if we remove mod 2, we need to downgrade mod 3 (which has version 4 and 5 > 3 (last patch removed)) by 2 versions,
	# the number 2 we get by counting the number of unique base names (without extensions like .stream, but with the .patch_[0-9]) in the files
	for base_name in "${!downgrades_to_remove[@]}"; do
		# find all files that have the same base name, and are greater than the current version, and downgrade them
		IFS=$'\n' mods_to_remove=($(ls "$MODS_DIR/$base_name"* 2>/dev/null | sort -V)); unset IFS
		base_name_with_patch=$(get_basename_with_patch_without_extension "$file")

		for mod in "${mods_to_remove[@]}"; do
			mod=$(get_filename_without_path "$mod")
			patch_version=$(echo $mod | grep -oP '(?<=patch_)\d+')
			if [[ $patch_version -gt ${downgrades_versions[$base_name_with_patch]} ]]; then
				new_version=$((patch_version - downgrades_to_remove["$base_name"] - 1))
				extension=$(get_extension "$mod")

				new_patch="${base_name}.patch_${new_version}${extension}"
				mv "$MODS_DIR/$mod" "$MODS_DIR/$new_patch"

				[[ $? -ne 0 ]] && { echo -e "${RED}Error${NC}: Could not downgrade mod file $mod." >&2; exit 1; }
				echo -e "Downgraded ${ORANGE}$mod${NC} to ${GREEN}\$MODS_DIR/$new_patch${NC}." >&2
				
				# save changes in database as well
				sed -i "s/$mod/$new_patch/" "$DB_FILE"
			fi
		done
	done

	# remove entry from database
	sed -i "/^$mod_index/d" "$DB_FILE"

	echo -e "Mod $mod_name ${ORANGE}uninstalled${NC} successfully." >&2
}

function mod_list() {
	[[ "$1" == "--help" || "$1" == "-h" ]] && { display_list_help; exit 0; }

	[[ ! -s "$DB_FILE" ]] && { echo "No mods installed."; return; }

	echo "Installed mods:" >&2

	awk -v GREEN="$GREEN" -v RED="$RED" -v NC="$NC" -F, '{
	color = ($2 == "DISABLED") ? RED : GREEN;
	if (length($4) > 150) $4 = substr($4, 1, 147) "...";
	printf "%2s. [%s%s%s] %s (%s)\n", $1, color, $2, NC, $3, $4}' "$DB_FILE"
}

function mod_export() {
	[[ "$1" == "--help" || "$1" == "-h" ]] && { display_export_help; exit 0; }

	echo -ne "Archive file will be saved in the current directory ($(pwd)). Continue? (Y/n): "
	read -r confirm
	if [[ "$confirm" == "y" || "$confirm" == "Y" || "$confirm" = "" ]]; then
		# create a temporary directory to store the mods
		OUT_DIR=$(mktemp -d)
		MODS_EXPORT_DIR="$OUT_DIR/Helldivers 2 Mods"
		mkdir -p "$MODS_EXPORT_DIR"
		cp "$DB_FILE" "$MODS_EXPORT_DIR"

		[[ $? -ne 0 ]] && { echo -e "${RED}Error${NC}: Could not copy mods to target directory." >&2; exit 1; }

		# copy all mod files to the export directory
		for file in $(ls "$MODS_DIR/" 2>/dev/null | grep -E 'patch_.*'); do
			cp "$MODS_DIR/$file" "$MODS_EXPORT_DIR"
		done

		[[ $? -ne 0 ]] && { echo -e "${RED}Error${NC}: Could not export mods. Possibly because no mods are present." >&2; exit 1; }

		# zip up the mods with the current date and time in the name
		current_path=$(pwd)
		archive_name="Helldivers_2_Mods_$(date +%Y-%m-%d_%H-%M-%S).tar.gz"
		tar -czf "$current_path/$archive_name" -C "$OUT_DIR" "Helldivers 2 Mods"

		[[ $? -ne 0 ]] && { echo -e "${RED}Error${NC}: Failed to export mods." >&2; exit 1; }
		echo -e "Mods exported to ${GREEN}$current_path/$archive_name${NC}." >&2
	fi
}

function mod_import() {
	[[ "$1" == "--help" || "$1" == "-h" ]] && { display_import_help; exit 0; }
	[[ ! -f "$1" ]] && { echo -e "${RED}Error${NC}: File $1 does not exist." >&2; exit 1; }

	# reset mods before importing
	echo -e "Importing mods will ${RED}reset${NC} your mods." >&2
	mod_reset

	[[ $? -eq 1 ]] && exit 1

	# extract in temp directory
	OUT_DIR=$(mktemp -d)
	tar -xzf "$1" -C "$OUT_DIR"

	[[ $? -ne 0 ]] && { echo -e "${RED}Error${NC}: Could not import mods. Possibly because the zip file is invalid." >&2; exit 1; }

	MODS_EXPORT_DIR="$OUT_DIR/Helldivers 2 Mods"
	[[ ! -d "$MODS_EXPORT_DIR" ]] && { echo -e "${RED}Error${NC}: Could not import mods. Possibly because the zip file is invalid." >&2; exit 1; }

	# copy mods verbosely
	cp -v "$MODS_EXPORT_DIR"/* "$MODS_DIR"

	[[ $? -ne 0 ]] && { echo -e "${RED}Error${NC}: Failed to import mods." >&2; exit 1; }
	echo -e "Mods imported ${GREEN}successfully${NC}." >&2
}

# --- Main ---

function main() {
	[[ $# -lt 1 ]] && { display_help; exit 1; }

	command="$1"
	shift
	initialize_directories
	check_for_updates

	case "$command" in
		install|i)
			mod_install "$@"
			;;
		list|l)
			mod_list "$@"
			;;
		uninstall|u)
			mod_uninstall "$@"
			;;
		enable|e)
			mod_enable "$@"
			;;
		disable|d)
			mod_disable "$@"
			;;
		export|ex)
			mod_export "$@"
			;;
		import|im)
			mod_import "$@"
			;;
		reset|r)
			mod_reset "$@"
			;;
		version|v|-v|--version)
			echo "${VERSION}"
			;;
		help|--help|-h|h)
			display_help
			;;
		*)
			display_help
			;;
	esac
}

main "$@"
